{"meta":{"title":"blog","subtitle":"","description":"","author":"Jichang Sun","url":"https://xxixx.site"},"pages":[],"posts":[{"title":"安装 Hexo!","slug":"2023-11-12-02","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":false,"path":"2023/11/24/2023-11-12-02/","permalink":"https://xxixx.site/2023/11/24/2023-11-12-02/","excerpt":"","text":"安装 Hexo","categories":[{"name":"分类1","slug":"分类1","permalink":"https://xxixx.site/categories/%E5%88%86%E7%B1%BB1/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://xxixx.site/tags/%E6%A0%87%E7%AD%BE1/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"https://xxixx.site/categories/%E5%88%86%E7%B1%BB1/"}]},{"title":"思维导图测试","slug":"2023-11-12-03","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":false,"path":"2023/11/24/2023-11-12-03/","permalink":"https://xxixx.site/2023/11/24/2023-11-12-03/","excerpt":"","text":"","categories":[{"name":"分类2","slug":"分类2","permalink":"https://xxixx.site/categories/%E5%88%86%E7%B1%BB2/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://xxixx.site/tags/%E6%A0%87%E7%AD%BE1/"}],"keywords":[{"name":"分类2","slug":"分类2","permalink":"https://xxixx.site/categories/%E5%88%86%E7%B1%BB2/"}]},{"title":"测试自动部署","slug":"2023-11-12-04","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":false,"path":"2023/11/24/2023-11-12-04/","permalink":"https://xxixx.site/2023/11/24/2023-11-12-04/","excerpt":"","text":"Markdown Editor built on Vue!! Links Demo Documentation Changelog Install12345# use npmnpm i @kangc/v-md-editor -S# use yarnyarn add @kangc/v-md-editor Quick Start12345678import Vue from &#x27;vue&#x27;;import VueMarkdownEditor from &#x27;@kangc/v-md-editor&#x27;;import &#x27;@kangc/v-md-editor/lib/style/base-editor.css&#x27;;import vuepressTheme from &#x27;@kangc/v-md-editor/lib/theme/vuepress.js&#x27;;VueMarkdownEditor.use(vuepressTheme);Vue.use(VueMarkdownEditor); Usage12345678910111213&lt;template&gt; &lt;v-md-editor v-model=&quot;text&quot; height=&quot;400px&quot;&gt;&lt;/v-md-editor&gt;&lt;/template&gt;&lt;script&gt; export default &#123; data() &#123; return &#123; text: &#x27;&#x27;, &#125;; &#125;, &#125;;&lt;/script&gt; Refrence ElementUi Scrollbar Component vuepress-plugin-container","categories":[{"name":"分类2","slug":"分类2","permalink":"https://xxixx.site/categories/%E5%88%86%E7%B1%BB2/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://xxixx.site/tags/%E6%A0%87%E7%AD%BE1/"}],"keywords":[{"name":"分类2","slug":"分类2","permalink":"https://xxixx.site/categories/%E5%88%86%E7%B1%BB2/"}]},{"title":"Hello World!!","slug":"2023-11-12-05","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":false,"path":"2023/11/24/2023-11-12-05/","permalink":"https://xxixx.site/2023/11/24/2023-11-12-05/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[{"name":"分类1","slug":"分类1","permalink":"https://xxixx.site/categories/%E5%88%86%E7%B1%BB1/"}],"tags":[{"name":"标签1","slug":"标签1","permalink":"https://xxixx.site/tags/%E6%A0%87%E7%AD%BE1/"}],"keywords":[{"name":"分类1","slug":"分类1","permalink":"https://xxixx.site/categories/%E5%88%86%E7%B1%BB1/"}]},{"title":"我个人使用的Github图床","slug":"2023-11-13-01","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":true,"path":"2023/11/24/2023-11-13-01/","permalink":"https://xxixx.site/2023/11/24/2023-11-13-01/","excerpt":"","text":"选择图床的小软件 uPic uPic下载地址 GitHub 图床的设置 创建Github账号 和 用来存放图片的仓库 （略） GitHub申请用来 操作的图片仓库token 进入Github Token 创建页面 勾选 repo 访问权限。然后滚动页面到底部，点击Generate token按钮来生成 Token 复制Token 注意：此 Token 只会显示一次！请务必保存好，否则之后丢失了，就得重新创建了 配置uPic Github图床 若存放图片的仓库 是私有的 CDN加速访问 不要勾选 若存放图片的仓库 是公有的 CDN加速访问 可以勾选 愉快的使用起来吧 其他图床的配置方法","categories":[{"name":"其他","slug":"其他","permalink":"https://xxixx.site/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://xxixx.site/tags/%E6%8A%80%E5%B7%A7/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://xxixx.site/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"Mac 显示隐藏文件1","slug":"2023-11-13-02","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":false,"path":"2023/11/24/2023-11-13-02/","permalink":"https://xxixx.site/2023/11/24/2023-11-13-02/","excerpt":"","text":"Mac显示隐藏文件1 最简单方式 使用组合快捷键 command + shift + . 这样隐藏文件就显示出来了","categories":[{"name":"其他","slug":"其他","permalink":"https://xxixx.site/categories/%E5%85%B6%E4%BB%96/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://xxixx.site/tags/%E6%8A%80%E5%B7%A7/"}],"keywords":[{"name":"其他","slug":"其他","permalink":"https://xxixx.site/categories/%E5%85%B6%E4%BB%96/"}]},{"title":"Hexo自动部署到Github后CNAME文件消失","slug":"2023-11-17-01","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":false,"path":"2023/11/24/2023-11-17-01/","permalink":"https://xxixx.site/2023/11/24/2023-11-17-01/","excerpt":"","text":"Hexo自动部署到Github后 CNAME 文件消失问题经过: 购买的域名，在github的 settings 下的 pages 配置项中设置了域名 会自动在 代码根目录 生成一个 CNAME 文件 文件内容即为 设置的域名 (xxixx.site) 设置好之后，访问设置的域名一切正常 但是我写的md文章 上传后 hexo自动部署后把CNAME文件给我删除了 解决方法其实这里有个技巧，我们可以将需要上传部署到Github的文件都放在source文件夹里，例如CNAME文件、favicon.ico、或者其他的图片等等，这样在执行hexo d这个命令之后，这些文件就不会被删除了。","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://xxixx.site/categories/Hexo/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://xxixx.site/tags/%E6%8A%80%E5%B7%A7/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://xxixx.site/categories/Hexo/"}]},{"title":"网站 favicon 设计","slug":"2023-11-18-01","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":false,"path":"2023/11/24/2023-11-18-01/","permalink":"https://xxixx.site/2023/11/24/2023-11-18-01/","excerpt":"","text":"网站 favicon 设计 推荐 favicon 可以根据图片&#x2F;文字&#x2F;Emoji等生成","categories":[{"name":"Hexo","slug":"Hexo","permalink":"https://xxixx.site/categories/Hexo/"}],"tags":[{"name":"技巧","slug":"技巧","permalink":"https://xxixx.site/tags/%E6%8A%80%E5%B7%A7/"}],"keywords":[{"name":"Hexo","slug":"Hexo","permalink":"https://xxixx.site/categories/Hexo/"}]},{"title":"前端面试-HTML 和 CSS","slug":"2023-11-19-01","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":true,"path":"2023/11/24/2023-11-19-01/","permalink":"https://xxixx.site/2023/11/24/2023-11-19-01/","excerpt":"","text":"HTML 和 CSS","categories":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xxixx.site/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端面试-JavaScript","slug":"2023-11-20-01","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":true,"path":"2023/11/24/2023-11-20-01/","permalink":"https://xxixx.site/2023/11/24/2023-11-20-01/","excerpt":"","text":"JavaScript","categories":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xxixx.site/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端面试-Vue","slug":"2023-11-20-02","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":true,"path":"2023/11/24/2023-11-20-02/","permalink":"https://xxixx.site/2023/11/24/2023-11-20-02/","excerpt":"","text":"Vue","categories":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xxixx.site/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端面试-React","slug":"2023-11-20-03","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":true,"path":"2023/11/24/2023-11-20-03/","permalink":"https://xxixx.site/2023/11/24/2023-11-20-03/","excerpt":"","text":"React","categories":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xxixx.site/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端面试-版本控制","slug":"2023-11-20-04","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":true,"path":"2023/11/24/2023-11-20-04/","permalink":"https://xxixx.site/2023/11/24/2023-11-20-04/","excerpt":"","text":"版本控制","categories":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xxixx.site/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端面试-网络和 HTTP","slug":"2023-11-20-05","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":true,"path":"2023/11/24/2023-11-20-05/","permalink":"https://xxixx.site/2023/11/24/2023-11-20-05/","excerpt":"","text":"网络和 HTTP","categories":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xxixx.site/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"前端面试-性能优化","slug":"2023-11-20-06","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":true,"path":"2023/11/24/2023-11-20-06/","permalink":"https://xxixx.site/2023/11/24/2023-11-20-06/","excerpt":"","text":"","categories":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"面试","slug":"面试","permalink":"https://xxixx.site/tags/%E9%9D%A2%E8%AF%95/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"手写Promise","slug":"2023-11-23-01","date":"2023-11-24T06:00:08.071Z","updated":"2023-11-24T06:00:08.071Z","comments":true,"path":"2023/11/24/2023-11-23-01/","permalink":"https://xxixx.site/2023/11/24/2023-11-23-01/","excerpt":"","text":"手写Promise核心逻辑实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245/* 1. Promise 就是一个类，在执行这个类的时候 需要传递一个执行器进去 执行器会立即执行 2. Promise 中有三种状态 分别为 成功 fulfilled 失败 rejected 等待 pending pending -&gt; fulfilled pending -&gt; rejected 一旦状态确定就不可更改 3. resolve和reject函数式用来更改状态的 resolve: fulfilled reject: rejected 4. then方法内部做的事情就判断状态 如果状态是成功 调用成功的回调函数 如果状态是失败调用失败的回调函数 then方法是被定义在原型对象中 5. then成功回调有一个参数 表示成功之后的值 then失败回调有一个参数 表示失败后的原因 */ const PENDING = &#x27;pending&#x27;; // pending等待状态 const FULFILLED = &#x27;fulfilled&#x27;; // resolve成功状态 const REJECTED = &#x27;rejected&#x27;; // reject失败状态 class MyPromise &#123; state = PENDING; // promise的初始状态，也就是默认状态是pending value = null; // resolve的value reason = null; // reject的reason onFulfilledCallback = []; // 成功时执行的函数 onRejectedCallback = []; // 失败时执行的函数 constructor(executor) &#123; try &#123; executor(this.resolve, this.reject); &#125; catch (error) &#123; this.reject(error) &#125; &#125; resolve = value =&gt; &#123; // 只有状态为pending时才可以resolve if (this.state === PENDING) &#123; // 修改状态为fulfilled this.state = FULFILLED; this.value = value; // 调用resolve修改状态为成功时，执行成功的处理函数 while (this.onFulfilledCallback.length) &#123; this.onFulfilledCallback.shift()(); &#125; &#125; &#125; reject = reason =&gt; &#123; // 只有状态为pending时才可以resolve if (this.state === PENDING) &#123; // 修改状态为rejected this.state = REJECTED; this.reason = reason; // 调用reject修改状态为失败时，执行失败的处理函数 while (this.onRejectedCallback.length) &#123; this.onRejectedCallback.shift()(); &#125; &#125; &#125; then = (onFulfilled, onRejected) =&gt; &#123; // 如果onFulfilled不是一个函数，则给它一个默认函数 if (typeof onFulfilled !== &#x27;function&#x27;) onFulfilled = value =&gt; value; // 如果onRejected不是一个函数，则给它一个默认函数，行为是抛出reason错误信息 if (typeof onRejected !== &#x27;function&#x27;) onRejected = reason =&gt; &#123; throw reason &#125;; let promise2 = new MyPromise((resolve, reject) =&gt; &#123; // 成功的处理函数 const onFulfilledCallback = () =&gt; &#123; // 执行onFulfilled并把我们的value传递给它 setTimeout(() =&gt; &#123; try &#123; // 得到resolve的返回值 const x = onFulfilled(this.value); // 根据返回值类型的不同，进行不同的操作 this.resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;) &#125; // 失败的处理函数 const onRejectedCallback = () =&gt; &#123; // 执行onRejected并把我们的reason传递给它 setTimeout(() =&gt; &#123; try &#123; // 得到reject的返回值 const x = onRejected(this.reason); // 根据返回值类型的不同，进行不同的操作 this.resolvePromise(promise2, x, resolve, reject); &#125; catch (error) &#123; reject(error); &#125; &#125;) &#125; // 只有当前状态为成功fulfilled时才执行 if (this.state === FULFILLED) &#123; onFulfilledCallback(); &#125; // 只有当前状态为成功rejected时才执行 if (this.state === REJECTED) &#123; onRejectedCallback(); &#125; // 只有当前状态为成功pending时才执行 if (this.state === PENDING) &#123; // 保存成功时的处理函数 this.onFulfilledCallback.push(onFulfilledCallback); // 保存失败时的处理函数 this.onRejectedCallback.push(onRejectedCallback); &#125; &#125;); return promise2; &#125; catch = (failCallback) =&gt; &#123; return this.then(undefined, failCallback) &#125; finally(callback) &#123; return this.then(value =&gt; &#123; return MyPromise.resolve(callback()).then(() =&gt; value) &#125;, reason =&gt; &#123; return MyPromise.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) &#125;) &#125; resolvePromise = (promise2, x, resolve, reject) =&gt; &#123; if (promise2 === x) reject(new TypeError(`循环引用错误`)); // 如果x是对象或者函数 if (x !== null &amp;&amp; (typeof x === &#x27;object&#x27; || typeof x === &#x27;function&#x27;)) &#123; // 声明一个变量then let then; // 声明一个变量called，代表y或r是否被调用过 let called = false; // false代表没有被调用过 try &#123; // 取出x.then并赋值给then（假如x被设置了不可读，则可能会报错，所以需要try/catch） then = x.then; &#125; catch (err) &#123; // 失败，reject reject(err); &#125; // 判断then是否是一个函数 if (typeof then === &#x27;function&#x27;) &#123; try &#123; // 修改then的this指向为x then.call( x, y =&gt; &#123; // 如果y或x已经被调用过，则直接退出 if (called) return; // 修改called为已调用 called = true; // 再次执行resolvePromise this.resolvePromise(promise2, y, resolve, reject); &#125;, r =&gt; &#123; // 如果y或x已经被调用过，则直接退出 if (called) return; // 修改called为已调用 called = true; // reject这个r reject(r); &#125; ) &#125; catch (e) &#123; // 如果y或x已经被调用过，则直接退出 if (called) return; // 如果then在被调用的过程中出错，则会进入这里，直接reject reject(e); &#125; &#125; else &#123; // 如果then不是一个函数，则以x进行resolve resolve(x); &#125; &#125; else &#123; // x不是对象，也不是函数，则以x进行resolve resolve(x); &#125; &#125; static resolve = (value) =&gt; &#123; return new MyPromise((resolve, reject) =&gt; &#123; resolve(value); &#125;) &#125; static reject = (reason) =&gt; &#123; return new MyPromise((resolve, reject) =&gt; &#123; reject(reason); &#125;) &#125; static all = (promises) =&gt; &#123; let result = []; let count = 0; // 判断参数是否是一个数组，如果不是数组，则不执行，直接返回该参数 if (!Array.isArray(promises)) return promises; return new MyPromise((resolve, reject) =&gt; &#123; // 往result里添加数据 const insertData = (data, index) =&gt; &#123; result[index] = data; count++; // 判断是否执行完毕 if (count === result.length) &#123; resolve(result); &#125; &#125; // 使用循环遍历所有promise并执行 for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(value =&gt; insertData(value, i), reject); &#125; &#125;) &#125; static race = (promises) =&gt; &#123; if (!Array.isArray(promises)) return promises; return new MyPromise((resolve, reject) =&gt; &#123; for (let i = 0; i &lt; promises.length; i++) &#123; promises[i].then(resolve, reject); &#125; &#125;) &#125; &#125; // 测试 MyPromise.deferred = MyPromise.defer = function () &#123; var defer = &#123;&#125;; defer.promise = new MyPromise(function (resolve, reject) &#123; defer.resolve = resolve; defer.reject = reject; &#125;) return defer; &#125; try &#123; module.exports = MyPromise &#125; catch (e) &#123; &#125; 测试结果","categories":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"手写代码","slug":"手写代码","permalink":"https://xxixx.site/tags/%E6%89%8B%E5%86%99%E4%BB%A3%E7%A0%81/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"https://xxixx.site/categories/%E5%89%8D%E7%AB%AF/"}]}]}